testModule::Module = (
	A::Type = <a, b, c:Int>
	B::Type = <c:Int, d:Char, e>

	Complex::Type = (
		re:Real
		im:Real

		add::(c1:Complex, c2:Complex)->Complex = (.re=c1.re + c2.re, .im=c1.im + c2.im)
		sub::(c1:Complex, c2:Complex)->Complex = (.re=c1.re - c2.re, .im=c1.im - c2.im)
	)

	FileError::Type = <
		fileNotFound:Int
		resourceBusy
	>

	AllocationError::Type = <
		outOfMemory
		resourceBusy
	>

	-- ->! is a double token morpheme
	-- Means the function will return the codomain error unioned with whatever enums are returned in the entire body of the function
	-- For eval exprs, returns, and try, if the type doesnt match with the ret type, but function is comptime, non-extern, implicit error function, and expr type is enum, add to union set
	-- Afterwards, type is updated to be the correct error union enum type

	lol::()->!Int = {
		FileError.fileNotFound
	}

	main::(args:[]String)->!() = {
		try lol() -- If type does not match for !(), implicit return of success
	}
)