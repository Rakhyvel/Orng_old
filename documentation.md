# Documentation
## Getting started, hello world
```
helloWorld::Module = (
    + main::(args:[]String)->!() = {
        stdlib.system.println("Hello, World!")
    }
)
```
## Small tutorial
## Comments
Comments start with `//` and end at the end of the line. Comments are ignored by the Orange compiler.
```
// stdlib.system.println("This will not print")
stdlib.system.println("This will!")
```
## Variable definitions
Variables are assigned using the following syntax
```
x: Int = 4
```
If the type is omitted, the type is infered from the expression
```
x: = 4 // Type is infered to be 4
```
If the expression is omitted, the expression is given a default zero-value
```
x: Int // = 0
```
Variable names must start with an underscore or any letter, but can contain underscores, letters, and numbers.

### Restriction list modifier
Variables can have an optional restriction list that starts with `-[` and ends in `]`. Any symbol included in the restriction list is visible in the variable's definition. If a variable does not declare a restriction list, all symbols in the parent scope are visible.
```
myModule::Module = (
    someGlobal: Int = 4
    -[someGlobal] otherGlobal: Int = someGlobal + 5

    -[]
    + main::(args:[]String)->!() = {
        someGlobal = 5 // Error! someGlobal is not allowed through restriction
    }
)
```
### External modifier
Variables can optionally be declared as external using `?`. When a variable is declared as external, it tells the Orange compiler that the variable isn't defined now, but will be at linktime.
```
? malloc::(size:Int64)->&()
someFunction::()->() = {
    allocatedBytes: &() = malloc(16)
}
```
External declarations can have an optional external name. This is the name that will be generated by Orange, and can be different from the variable name used by Orange. This is useful when the external name would be awkward to work with.
```
sdl::Module = (
    // These two reference the same external function SDL_Init
    ?[SDL_Init] + init::(flags:Int32)->Int
    ? + SDL_Init::(flags:Int32)->Int
)
```
```
myModule::Module = (
    + myFunction::()->() = {
        // Compare...
        sdl.init(0)
        // With...
        sdl.SDL_Init(0)
    }
)
```
If no external name is given, Orange will use the variable's name.

External variables do not need an expression since they will not be generated by Orange. However, for external types it can be useful to provide a representation to Orange about the structure of the external type.
```
// External C Code
typedef struct {
    int a;
    char b;
    float c;
} MyStruct;
```
```
// Orange Code
?[MyStruct] MyStruct_version1::Type

?[MyStruct] MyStruct_version2::Type = (
    a: Int
    b: Char
    c: Real
)

main::()->() = {
    version1: MyStruct_version1
    version2: MyStruct_version2

    version1.a = 5 // Error! Orange cannot verify if this is correct
    version2.a = 5 // Ok! Orange is able to verify that this is correct
}
```
Struct fields cannot be marked as external

### Public modifier
Variables can be marked as public using `+`, similar to UML. Public variables can be accessed in cousin scopes using the `.` operator. Variables that aren't explicitly defined as public are private. All variables, both public and private, are visible in children scopes.
```
someModule::Module = (
    + visible: Int = 5
    invisible: Int = 7
)
```
```
otherModule::Module = (
    myInvisible: Char = '2'
    + main::()->() = {
        someModule.visible = 5      // Ok
        myInvisible = 5             // Ok
        someModule.invisible = 5    // Error! someModule's invisible variable is not public
    }
)
```
Struct fields are implicitly public. It is still syntactically correct to mark them as public if you really want to.
## Primitive types
There are 14 primitive types in Orange.
| Type    | C Equivalent | Description                                                                                                       |
|---------|--------------|-------------------------------------------------------------------------------------------------------------------|
| ()      | void         | 0 bit type                                                                                                        |
| Int8    | int8_t       | 8 bit signed integer                                                                                              |
| Char    | char         | a character on the system (usually 8 bits)                                                                        |
| Int16   | int16_t      | 16 bit signed integer                                                                                             |
| Int32   | int32_t      | 32 bit signed integer                                                                                             |
| Int     | int32_t      | shorthand for Int32                                                                                               |
| Int64   | int64_t      | 64 bit signed integer                                                                                             |
| Real32  | float        | 32 bit floating point number                                                                                      |
| Real    | float        | shorthand for Real32                                                                                              |
| Real64  | double       | 64 bit floating point number                                                                                      |
| Type    | -            | a type in Orange                                                                                                  |
| Enum    | unsigned int | a list of values enumerated                                                                                       |
| Module  | -            | a namespace and singleton list of variable definitions                                                            |
| Package | -            | a namespace, root node in program symbol tree, and a singleton list of compile-time constant variable definitions |
There are no unsigned integer types because no one seems to truly understand how unsigned integer arithmetic works.

All types must start with a capital letter, except for the `()` type.
## Constant types
Types can be declared constant by adding a `:` in front of their type declaration. 
```
// Value of constants cannot be changed
pi::Real = 3.14159

// Address this points to cannot be changed
// Memory at this address can be changed
constPtr::&Int = null

// Address this points to CAN be changed
// Memory at this address CANNOT be changed
freePtr: &:Int = null

// Neither address, nor memory can be changed
constConstptr::&:Int = null
```
## Structs

## Arrays
## Enums
## Unions
## Functions
## Operators
## if
## for
## switch
## new/free
## defer
## Compile-time evaluation
## Errors, errdefer, try, catch
## Optionals, orelse
## Generics
## Methods
## Iterators
## Quantifiers
## Package system
## Testing