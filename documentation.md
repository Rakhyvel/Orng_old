# Documentation
## Getting started, hello world
```
helloWorld::Module = (
    + main::(args:[]String)->!() = {
        stdlib.system.println("Hello, World!")
    }
)
```
## Small tutorial
## Comments
Comments start with `//` and end at the end of the line. Comments are ignored by the Orange compiler.
```
// stdlib.system.println("This will not print")
stdlib.system.println("This will!")
```
## Variable definitions
Variables are assigned using the following syntax
```
x: Int = 4
```
If the type is omitted, the type is infered from the expression
```
x: = 4 // Type is infered to be 4
```
If the expression is omitted, the expression is given a default zero-value
```
x: Int // = 0
```
Variable names must start with an underscore or any letter, but can contain underscores, letters, and numbers.

### Restriction list modifier
Variables can have an optional restriction list that starts with `-[` and ends in `]`. Any symbol included in the restriction list is visible in the variable's definition. If a variable does not declare a restriction list, all symbols in the parent scope are visible.
```
myModule::Module = (
    someGlobal: Int = 4
    -[someGlobal] otherGlobal: Int = someGlobal + 5

    -[]
    + main::(args:[]String)->!() = {
        someGlobal = 5 // Error! someGlobal is not allowed through restriction
    }
)
```
### External modifier
Variables can optionally be declared as external using `?`. When a variable is declared as external, it tells the Orange compiler that the variable isn't defined now, but will be at linktime.
```
? malloc::(size:Int64)->&()
someFunction::()->() = {
    allocatedBytes: &() = malloc(16)
}
```
External declarations can have an optional external name. This is the name that will be generated by Orange, and can be different from the variable name used by Orange. This is useful when the external name would be awkward to work with.
```
sdl::Module = (
    // These two reference the same external function SDL_Init
    ?[SDL_Init] + init::(flags:Int32)->Int
    ? + SDL_Init::(flags:Int32)->Int
)
```
```
myModule::Module = (
    + myFunction::()->() = {
        // Compare...
        sdl.init(0)
        // With...
        sdl.SDL_Init(0)
    }
)
```
If no external name is given, Orange will use the variable's name.

External variables do not need an expression since they will not be generated by Orange. However, for external types it can be useful to provide a representation to Orange about the structure of the external type.
```
// External C Code
typedef struct {
    int a;
    char b;
    float c;
} MyStruct;
```
```
// Orange Code
?[MyStruct] MyStruct_version1::Type

?[MyStruct] MyStruct_version2::Type = (
    a: Int
    b: Char
    c: Real
)

main::()->() = {
    version1: MyStruct_version1
    version2: MyStruct_version2

    version1.a = 5 // Error! Orange cannot verify if this is correct
    version2.a = 5 // Ok! Orange is able to verify that this is correct
}
```
Struct fields cannot be marked as external

### Public modifier
Variables can be marked as public using `+`, similar to UML. Public variables can be accessed in cousin scopes using the `.` operator. Variables that aren't explicitly defined as public are private. All variables, both public and private, are visible in children scopes.
```
someModule::Module = (
    + visible: Int = 5
    invisible: Int = 7
)
```
```
otherModule::Module = (
    myInvisible: Char = '2'
    + main::()->() = {
        someModule.visible = 5      // Ok
        myInvisible = 5             // Ok
        someModule.invisible = 5    // Error! someModule's invisible variable is not public
    }
)
```
Struct fields are implicitly public. It is still syntactically correct to mark them as public if you really want to.
## Primitive types
There are 14 primitive types in Orange.
| Type    | C Equivalent | Description                                                                                                       |
|---------|--------------|-------------------------------------------------------------------------------------------------------------------|
| ()      | void         | 0 bit type                                                                                                        |
| Int8    | int8_t       | 8 bit signed integer                                                                                              |
| Char    | char         | a character on the system (usually 8 bits)                                                                        |
| Int16   | int16_t      | 16 bit signed integer                                                                                             |
| Int32   | int32_t      | 32 bit signed integer                                                                                             |
| Int     | int32_t      | shorthand for Int32                                                                                               |
| Int64   | int64_t      | 64 bit signed integer                                                                                             |
| Real32  | float        | 32 bit floating point number                                                                                      |
| Real    | float        | shorthand for Real32                                                                                              |
| Real64  | double       | 64 bit floating point number                                                                                      |
| Type    | -            | a type in Orange                                                                                                  |
| Enum    | unsigned int | a list of values enumerated                                                                                       |
| Module  | -            | a namespace and singleton list of variable definitions                                                            |
| Package | -            | a namespace, root node in program symbol tree, and a singleton list of compile-time constant variable definitions |

There are no unsigned integer types because no one seems to truly understand how unsigned integer arithmetic works.

All types must start with a capital letter, except for the `()` type.
## Constant types
Types can be declared constant by adding a `:` in front of their type declaration. 
```
// Value of constants cannot be changed
pi::Real = 3.14159

// Address this points to cannot be changed
// Memory at this address can be changed
constPtr::&Int = null

// Address this points to CAN be changed
// Memory at this address CANNOT be changed
freePtr: &:Int = null

// Neither address, nor memory can be changed
constConstptr::&:Int = null
```
## Type aliasing
Orange uses structural type equivalence. That means two types are the same if their underlying type structure is the same. New type aliases are defined using a variable definition and the Type type.
```
MyNewIntType::Type = Int32
SomeOneElsesIntType:Type = Int32

// ...

a: MyNewIntType = 5
b: SomeOneElsesIntType = 6
a = b // Ok! 
```
## Structs
Structs are collections of definitions, similar to modules. Unlike modules, they can have instances created.

```
position: (x:Real, y:Real)
position.x = 5.4
position.y = -0.1
```
### Struct type aliasing
Structs are often aliased for compactness.
```
Vector::Type = (
    x: Real
    y: Real
)

position: Vector
position.x = 5.4
position.y = -0.1
```
### Struct zero-values
The zero-value of a struct is the zero-value of all it's fields.
```
position: Vector // x=0.0, y=0.0
```
### Default field values
Structs can have default field values. These override the zero-values of their fields.
```
Book::Type = (
    title: String = "untitled"
    author: String = "unknown"
    isbn: Int = -1
)
greenEggsAndHam: Book // title="untitled", author="unknown", isbn=-1
```
### Positional argument lists
Argument lists are used to instantiate a struct. Argument lists are untyped by default, so a cast is necessary.

Positional argument lists give their fields in the same order as the struct definition.
```
greatGatsby:Book = ("The Great Gatsby", "F. Scott Fitzgerald", 101):Book
```
Argument lists can leave off fields that are defaults. For example:
```
MyStruct::Type = (
    a:Int
    b:Int = 2
    c:Int
    d:Int = 4
)

// Here, `d` field is missing
// The default value specified by the struct is used
x := (1, 2, 3):MyStruct

// This is an error, because the `c` field is missing
// The `c` field does not have a default value
x := (1):MyStruct
```
### Named argument lists
Arguments can also assign the fields directly and in any order using the `.` operator, the name of the field, the `=` character, and then the expression.
```
Book::Type = (
    title: String = "untitled"
    author: String = "unknown"
    isbn: Int = -1
)

greatGatsby:Book = (.title="The Great Gatsby", .author="F. Scott Fitzgerald", .isbn=101):Book
```
The fields can be specified in any order.
```
// All Ok
(.title="The Odyssey", .author="Homer", .isbn=42):Book
(.title="The Odyssey", .isbn=42, .author="Homer"):Book
(.author="Homer", .title="The Odyssey", .isbn=42):Book
(.author="Homer", .isbn=42, .title="The Odyssey"):Book
(.isbn=42, .title="The Odyssey", .author="Homer"):Book
(.isbn=42, .author="Homer", .title="The Odyssey"):Book
```
The same field cannot be specified more than once.
```
// Error! author field specified more than once
(.title="The Odyssey", .author="Homer", .isbn=42, .author="Homer Simpson",):Book
```
Fields with default values can be left out. Their value will be the field's default value
```
(.title="The Catcher in the Rye"):Book // Ok!
```
Fields without default values must be specified.
```
MyStruct::Type = (
    a:Int
    b:Int = 5
)

// ...

// Error! a is never specified
myStruct := (.b=4):MyStruct
```
Finally, you cannot mix positional and named arguments.
```
// Error! Cannot mix positional and named arguments
("The Grapes Of Wrath", .author="John Steinbeck", 146):Book
```
## Addresses
## Arrays
## Enums
## Unions
## Functions
## Operators
## if
## for
## switch
## new/free
## defer
## Compile-time evaluation
## Errors, errdefer, try, catch
## Optionals, orelse
## Generics
## Methods
## Iterators
## Quantifiers
## Package system
## Testing