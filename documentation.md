# Documentation
## Getting started, hello world
```
helloWorld::Module = (
    + main::(args:[]String)->!() = {
        stdlib.system.println("Hello, World!")
    }
)
```
## Small tutorial
## Comments
Comments start with `//` and end at the end of the line. Comments are ignored by the Orange compiler.
```
// stdlib.system.println("This will not print")
stdlib.system.println("This will!")
```
## Variable definitions
Variables are assigned using the following syntax
```
x: Int = 4
```
If the type is omitted, the type is infered from the expression
```
x: = 4 // Type is infered to be 4
```
If the expression is omitted, the expression is given a default zero-value
```
x: Int // = 0
```
Variable names must start with an underscore or any letter, but can contain underscores, letters, and numbers.

### Restriction list modifier
Variables can have an optional restriction list that starts with `-[` and ends in `]`. Any symbol included in the restriction list is visible in the variable's definition. If a variable does not declare a restriction list, all symbols in the parent scope are visible.
```
myModule::Module = (
    someGlobal: Int = 4
    -[someGlobal] otherGlobal: Int = someGlobal + 5

    -[]
    + main::(args:[]String)->!() = {
        someGlobal = 5 // Error! someGlobal is not allowed through restriction
    }
)
```
### External modifier
Variables can optionally be declared as external using `?`. When a variable is declared as external, it tells the Orange compiler that the variable isn't defined now, but will be at linktime.
```
? malloc::(size:Int64)->&()
someFunction::()->() = {
    allocatedBytes: &() = malloc(16)
}
```
External declarations can have an optional external name. This is the name that will be generated by Orange, and can be different from the variable name used by Orange. This is useful when the external name would be awkward to work with.
```
sdl::Module = (
    // These two reference the same external function SDL_Init
    ?[SDL_Init] + init::(flags:Int32)->Int
    ? + SDL_Init::(flags:Int32)->Int
)
```
```
myModule::Module = (
    + myFunction::()->() = {
        // Compare...
        sdl.init(0)
        // With...
        sdl.SDL_Init(0)
    }
)
```
If no external name is given, Orange will use the variable's name.

External variables do not need an expression since they will not be generated by Orange. However, for external types it can be useful to provide a representation to Orange about the structure of the external type.
```
// External C Code
typedef struct {
    int a;
    char b;
    float c;
} MyStruct;
```
```
// Orange Code
?[MyStruct] MyStruct_version1::Type

?[MyStruct] MyStruct_version2::Type = (
    a: Int
    b: Char
    c: Real
)

main::()->() = {
    version1: MyStruct_version1
    version2: MyStruct_version2

    version1.a = 5 // Error! Orange cannot verify if this is correct
    version2.a = 5 // Ok! Orange is able to verify that this is correct
}
```
Struct fields cannot be marked as external

### Public modifier
Variables can be marked as public using `+`, similar to UML. Public variables can be accessed in cousin scopes using the `.` operator. Variables that aren't explicitly defined as public are private. All variables, both public and private, are visible in children scopes.
```
someModule::Module = (
    + visible: Int = 5
    invisible: Int = 7
)
```
```
otherModule::Module = (
    myInvisible: Char = '2'
    + main::()->() = {
        someModule.visible = 5      // Ok
        myInvisible = 5             // Ok
        someModule.invisible = 5    // Error! someModule's invisible variable is not public
    }
)
```
Struct fields are implicitly public. It is still syntactically correct to mark them as public if you really want to.
## Primitive types
There are 14 primitive types in Orange.
| Type    | C Equivalent | Description                                                                                                       |
|---------|--------------|-------------------------------------------------------------------------------------------------------------------|
| ()      | void         | 0 bit type                                                                                                        |
| Int8    | int8_t       | 8 bit signed integer                                                                                              |
| Char    | char         | a character on the system (usually 8 bits)                                                                        |
| Int16   | int16_t      | 16 bit signed integer                                                                                             |
| Int32   | int32_t      | 32 bit signed integer                                                                                             |
| Int     | int32_t      | shorthand for Int32                                                                                               |
| Int64   | int64_t      | 64 bit signed integer                                                                                             |
| Real32  | float        | 32 bit floating point number                                                                                      |
| Real    | float        | shorthand for Real32                                                                                              |
| Real64  | double       | 64 bit floating point number                                                                                      |
| Type    | -            | a type in Orange                                                                                                  |
| Enum    | unsigned int | a list of values enumerated                                                                                       |
| Module  | -            | a namespace and singleton list of variable definitions                                                            |
| Package | -            | a namespace, root node in program symbol tree, and a singleton list of compile-time constant variable definitions |

There are no unsigned integer types because no one seems to truly understand how unsigned integer arithmetic works.

All types must start with a capital letter, except for the `()` type.
## Constant types
Types can be declared constant by adding a `:` in front of their type declaration. 
```
// Value of constants cannot be changed
pi::Real = 3.14159

// Address this points to cannot be changed
// Memory at this address can be changed
constPtr::&Int = null

// Address this points to CAN be changed
// Memory at this address CANNOT be changed
freePtr: &:Int = null

// Neither address, nor memory can be changed
constConstptr::&:Int = null
```
## Type aliasing
Orange uses structural type equivalence. That means two types are the same if their underlying type structure is the same. New type aliases are defined using a variable definition and the `Type` type.
```
MyNewIntType::Type = Int32
SomeOneElsesIntType::Type = Int32

// ...

a: MyNewIntType = 5
b: SomeOneElsesIntType = 6
a = b // Ok! 
```
## Structs
Structs are collections of definitions, similar to modules. Unlike modules, they can have multiple instances created.

```
position: (x:Real, y:Real)
position.x = 5.4
position.y = -0.1
```
### Struct type aliasing
Structs are often aliased for compactness.
```
Vector::Type = (
    x: Real // Commas are optional if a newline is present
    y: Real
)

position: Vector
position.x = 5.4
position.y = -0.1
```
### Struct zero-values
The zero-value of a struct is the zero-value of all it's fields.
```
position: Vector // x=0.0, y=0.0
```
### Default field values
Struct fields can have default values. These override the field's zero-values.
```
Book::Type = (
    title: String = "untitled"
    author: String = "unknown"
    isbn: Int = -1
)
greenEggsAndHam: Book // title="untitled", author="unknown", isbn=-1
```
### Positional argument lists
Argument lists are used to instantiate a struct. Argument lists are untyped by default, so a cast is necessary.

Positional argument lists give their values in the same order as the fields in the struct.
```
greatGatsby:Book = ("The Great Gatsby", "F. Scott Fitzgerald", 101):Book
```
Argument lists can leave off fields that have default values specified. For example:
```
MyStruct::Type = (
    a:Int
    b:Int = 2
    c:Int
    d:Int = 4
)

// Here, `d` field is missing
// The default value  for `d` is used
x := (1, 2, 3):MyStruct

// This is an error, because the `c` field is missing
// The `c` field does not have a default value
x := (1):MyStruct
```
### Named argument lists
Argument lists can also assign the fields directly, and in any order, using the syntax `.<field-name>=<expr>`
```
Book::Type = (
    title: String = "untitled"
    author: String = "unknown"
    isbn: Int = -1
)

greatGatsby:Book = (.title="The Great Gatsby", .author="F. Scott Fitzgerald", .isbn=101):Book
```
The fields can be specified in any order in a named argument list.
```
// All Ok
(.title="The Odyssey", .author="Homer", .isbn=42):Book
(.title="The Odyssey", .isbn=42, .author="Homer"):Book
(.author="Homer", .title="The Odyssey", .isbn=42):Book
(.author="Homer", .isbn=42, .title="The Odyssey"):Book
(.isbn=42, .title="The Odyssey", .author="Homer"):Book
(.isbn=42, .author="Homer", .title="The Odyssey"):Book
```
The same field cannot be specified more than once.
```
// Error! author field specified more than once
(.title="The Odyssey", .author="Homer", .isbn=42, .author="Homer Simpson"):Book
```
Fields with default values can be left out. Their default value will be used.
```
(.title="The Catcher in the Rye"):Book // Ok!
```
Fields without default values must be specified.
```
MyStruct::Type = (
    a:Int
    b:Int = 5
)

// ...

// Error! The field `a` is never specified
myStruct := (.b=4):MyStruct
```
Finally, you cannot mix positional and named arguments.
```
// Error! Cannot mix positional and named arguments
("The Grapes Of Wrath", .author="John Steinbeck", 146):Book
```
## Addresses
Addresses can be made using `&` before the type.
```
addrOfInt: &Int
addrOfAddrOfInt: &&Int
```
Addresses are platform specific addresses to some place in memory.
## Arrays
Arrays in Orange are contiguous chunks of memory. Unlike in C, arrays *are* that memory, not just pointers. Also unlike C, the length of the array is known and stored at the beginining of the array.

Arrays are closely related to structs. They have two fields, `length` and `data`. `length` is an integer and is how long the array is. `data` is the first element in the array. You can take the address of the `data` field to get a C compatible array, if needed.

### Fixed arrays
There are two forms of arrays, fixed and dynamic. Fixed arrays are stored in-place either on the stack or within a struct. They are declared using `[x]` where `x` is a compile-time constant expression.
```
myArr: [5]Int          // Array of 5 integers
chessBoard: [8][8]Char // An array of arrays
```
The zero-value of a fixed array is the length of the array along with the zero-value of all the elements.
```
someArr: [5]Bool // 5 booleans, all set to false
```
Fixed arrays are equivalent when the type of the two arrays matches **and** and the length matches.
```
arr1: [5]Int
arr2: [5]Int
arr3: [6]Int
arr1 = arr2 // Ok, simple byte-for-byte copy
arr1 = arr3 // Error! [5]Int is not compatible with [6]Int
```
Unlike in C, the length does not have to be an integer literal. The length can be any positive compile-time integer expression.
```
someConst::Int = 6
anotherConst::Int = 3
arr: [someConst * anotherConst]Char
arr2: [arr.length]Char // Ok! Fixed array lengths are known at compile time
```
Fixed arrays can be instantiated using an array literal.
```
someNumbers: [5]Int = [1, 2, 3, 4, 5]
moreNumbers := [6, 7, 8, 9, 10] // Types can be infered from array literals
```
All arrays can be indexed using square brackets. Array indices start at 0.
```
moreNumbers := [6, 7, 8, 9, 10]
seven: Int = moreNumbers[1]
```
### Dynamic arrays
Dynamic arrays are addresses of arrays. They can point to an array of any length. They are formed with the empty `[]` token.
```
arr: []Int
arr2: [][]Int
```
The built in `String` type is a dynamic array of characters.
```
String::Type = []Char
```
Dynamic arrays are useful for accepting arrays of any size as input to a function.
```
// Accepts an address of an integer array of any size, prints it out
printInts::(ints: []Int)->() = {
    for i := 0; i < ints.length; i += 1 {
        stdlib.system.println("%d", ints[i])
    }
}

+ main::()->() = {
    // Two arrays of different sizes
    arr1: [3]Int = [1, 2, 3]
    arr2: [4]Int = [1, 2, 3, 4]
    
    printInts(&arr1)    // These both work
    printInts(&arr2)
}
```
## Enums
Enums are lists of values. They can be created using the `Enum` type.
```
Color::Enum = (
    RED
    GREEN
    BLUE
)
```
Enums are accessed through their namespace, they are not added to the global name pool like in C.
```
color := Color.RED
```
Variables of integer types can be assigned enums, however variables of enum types cannot be assigned integers. Likewise, different enums are considered different types.
```
Color::Enum = (
    RED
    GREEN
    BLUE
)
Color2::Enum = (
    RED
    GREEN
    BLUE
)
var1: Color = Color.RED   // Ok
var2: Int   = Color2.RED  // Ok
var3: Color = Color2.BLUE // Error! Cannot mix between two enums
var4: Color = 5           // Error! Cannot assign an integer to an enum
```
### Enum length field
Not implemented yet.
### Enum toString function
Not implemented yet.
## Unions
Not implemented yet.
## Functions
Function types are created by using an arrow `->`. The arrow is left-associative. The domain type of a function must be a parameter list. The co-domain type of the function can be any type.
```
sqrt:(x:Real)->Real
main:(args:[]String)->Int
curry:(x:Int)->(y:Int)->Int
```
Compile-time constant function types are proper functions that require a statement as their expression.
```
// Functions can take any statement as their expression, not just blocks
f::(x:Real)->Real = return x * x + 2 * x

branch::(predicate:Bool)->Int = 
if predicate {
    return 5
} else {
    return 7
}

// Since defines are statements, this is possible
// Just not very useful!
this::()->() = is::()->() = weird::()->() = stdlib.system.println("Haha!") 
``` 
Constant functions must return a value from their co-domain through all control-flow paths.
```
// This function type has Int as it's co-domain
function::(x:Int)->Int = {
    if x > 4 {
        stdlib.system.println("I'm not gonna return anything!")
        // Error here, since this path does not return an Int
    } else {
        return 5
    }
}
```
Variable function types are function pointers.
```
// Constant functions, cannot re-assign
main::()->() = {}
otherMain::()->() = {}

// Variable functions, can reassign to functions of the same type
fxnPtr: ()->() = main
fnxPtr = otherMain
```
### Calling functions
A function call is made by joining the function's symbol description with an argument list. 

The parameter list of a function is syntactically the same as a struct definition, and the argument list is the same as a struct literal. So default parameters and position/named arguments work the same for functions as they did above for structs.
```
someFunction::()->() = {}
someFunction()

defaultValues::(a:Int = 4, b:Char = 5)->() = {}
defaultValues(.b=4)

arrOfFns: [](a:Int = 4, b:Char = 5)->() = ...
arrOfFns[x](7)
```
### Inner functions
Functions may be defined inside other functions. The inner function cannot see the variables defined in the outer function.
```
outer::()->() = {
    var: Int = 4

    inner::()->() = {
        var += 4 // Error! Inner function cannot see variables in outer function's scope
    }

    inner()
}
```
## Operators
| Syntax           | Types                    | Description                                                                                |
|------------------|--------------------------|--------------------------------------------------------------------------------------------|
| a = b            | B <: A                   | Assignment.                                                                                |
| a ? b ; c        | A <: Bool, B <: C C <: B | Ternary operator.                                                                          |
| a \|\| b         | A <: Bool, B <: Bool     | Logical or.                                                                                |
| a && b           | A <: Bool, B <: Bool     | Logical and.                                                                               |
| a \| b           | A <: Int64, B <: Int64   | Bitwise or.                                                                                |
| a ^ b            | A <: Int64, B <: Int64   | Bitwise xor.                                                                               |
| a & b            | A <: Int64, B <: Int64   | Bitwise and.                                                                               |
| a != b           | A <: B, B <: A           | Not equals.                                                                                |
| a == b           | A <: B, B <: A           | Equals.                                                                                    |
| a <= b           | A <: Real64, B <: Real64 | Less than or equal to.                                                                     |
| a >= b           | A <: Real64, B <: Real64 | Greater than or equal to.                                                                  |
| a < b            | A <: Real64, B <: Real64 | Less than.                                                                                 |
| a > b            | A <: Real64, B <: Real64 | Greater than.                                                                              |
| a << b           | A <: Int64, B <: Int64   | Left shift.                                                                                |
| a >> b           | A <: Int64, B <: Int64   | Right shift.                                                                               |
| a - b            | A <: Real64, B <: Real64 | Subtraction.                                                                               |
| a + b            | A <: Real64, B <: Real64 | Addition.                                                                                  |
| a % b            | A <: Int64, B <: Int64   | Modulus.                                                                                   |
| a / b            | A <: Real64, B <: Real64 | Division.                                                                                  |
| a * b            | A <: Real64, B <: Real64 | Multiplication.                                                                            |
| \|A\|            | A <: Type                | Size of type.                                                                              |
| ~a               | A <: Int64               | Bitwise negation.                                                                          |
| -a               | A <: Real64              | Negation.                                                                                  |
| *a               | A is an address          | Dereference.                                                                               |
| &a               | -                        | Address of. `a` must be an l-value                                                         |
| !a               | A <: Bool                | Boolean not.                                                                               |
| a.b              | -                        | Dot. `b` must be an identifier, and must be contained within the symbol referred to by `a` |
| a:B              | A is compatible with B   | Type cast.                                                                                 |
| a[b]             | A is an array, B <: Int64| Array indexing. `a` must be an array, cannot index an address                              |
| new A            | A is a type              | Allocation. Calls malloc, fills data with zero-value                                       |
## if
Evaluates the condition, if it evaluates to true, runs the code in the block.
```
x: Int = 2
if x < 4 {
    x = 4
}
stdlib.system.println("x will now be greater than or equal to 4")
```
An else block is optional. If the condition evaluates to false, the else block will run.
```
if false {
    stdlib.system.println("This won't run")
} else {
    stdlib.system.println("This will")
}
```
## for
Takes in three statements. The first statement will be executed first, then while the second statement evaluates to true, the block will be run. After each loop, the third statement will run.
```
// Counts from 1-10
for i := 1; i <= 10; i += 1 {
    stdlib.system.println("%d", i)
}
```
The outer two statements are optional
```
// All these both count from 1-10

i := 1
for ; i <= 10; i += 1 {
    stdlib.system.println("%d", i)
}

for i:= 0; i <= 10; {
    stdlib.system.println("%d", i)
    i += 1
}
```
If only one statement is specified, the for loop acts as a `while` loop in C.
```
for true {
    stdlib.system.println("infinite loop!")
}
```
### break
`break` statements end a `for` loop.
```
printUpTo7::()->() = {
    for i := 0; i < 7; i += 1 {
        if i == 7 {
            break
        }
        stdlib.system.println("%d", i)
    }
}
```
### continue
`continue` statements end the current iteration.
```
printEvens::()->() = {
    for i := 0; i < 10; i += 1 {
        if i % 2 == 1 {
            continue
        }
        stdlib.system.println("%d", i)
    }
}
```
## return
The `return` keyword sets the return value of a function and exits the function.
```
max::(a:Real64, b:Real64)->Real64 = return a > b ? a ; b
```
## switch
Switch statements in Orange are like switch statements in C, except that cases are blocks that do not fall through.
```
x: Int = stdlib.system.rand()
switch x % 4 {
    case 0, 2 { // 'Chain multiple cases using commas
        stdlib.system.println("x was even")
    }
    case 1 {
        stdlib.system.println("x was one more than a multiple of four")
    }
    else { // 'else' keyword rather than 'default'
        stdlib.system.println("x was something else")
    }
}
```
## new
The `new` operator allocates a new type on the heap. The value will be filled with it's zero-value.
```
MyType::Type = (
    a: Int = 4
    b: Char = 'd'
)

x: &MyType = new MyType // x.a=4, x.b='d'
```
## free
The `free` operator frees an address allocated with `new`.
```
x := new Int
free x
```
## defer
The `defer` keyword delays the running of code until the end of the current block. Defers will be run in the reverse order that they were setup. Works with break/continue/return and in nested loops.
```
myFunction::(x:Int, y:Int)->() = {
    for true {
        arr: [][]Char = new [x][]Char
        for i := 0; i < x; i += 1 {
            arr[i] = new [y]Char
        }
        // Will run at the end of every loop, NOT at the end of the function
        defer {
            for i := 0; i < x; i += 1 {
                free arr[i]
            }
            free arr
        }

        // Oh no something bad happened in the code! Time to bail!
        if rand() % 4 = 0 {
            return      // Our defer cleanup code will run before the function exits, no leaked memory!
        } else if rand() % 4 = 0 {
            continue    // Works with continue's
        } else if rand() % 4 = 0 {
            break       // and break's
        }

        // If execution gets to the end of a block, defers are automatically run in reverse order
    }
}
```
## Compile-time evaluation
Not implemented yet.
## Errors, errdefer, try, catch
Not implemented yet.
## Optionals, orelse
Not implemented yet.
## Generics
Not implemented yet.
## Methods
Not implemented yet.
## Iterators
Not implemented yet.
## Quantifiers
Not implemented yet.
## Package system
TODO
## Testing
Not implemented yet.