# Documentation
## Getting started, hello world
```
helloWorld::Module = (
    + main::(args:[]String)->!() = {
        stdlib.system.println("Hello, World!")
    }
)
```
## Small tutorial
## Comments
Comments start with `//` and end at the end of the line. Comments are ignored by the Orange compiler.
```
// stdlib.system.println("This will not print")
stdlib.system.println("This will!")
```
## Variable definitions
Variables are assigned using the following syntax
```
x: Int = 4
```
If the type is omitted, the type is infered from the expression
```
x: = 4 // Type is infered to be 4
```
If the expression is omitted, the expression is given a default zero-value
```
x: Int // = 0
```
Variable names must start with an underscore or any letter, but can contain underscores, letters, and numbers.

### Restriction list modifier
Variables can have an optional restriction list that starts with `-[` and end in `]`. Any symbol included in the restriction list is visible in the variable's definition. If a variable does not include a restriction, all symbols in the parent scope are visible.
```
myModule::Module = (
    someGlobal: Int = 4
    -[someGlobal] otherGlobal: Int = someGlobal + 5

    -[]
    + main::(args:[]String)->!() = {
        someGlobal = 5 // Error! someGlobal is not allowed through restriction
    }
)
```
### External modifier
Variables can optionally be declared as external. When a variable is declared as external, it tells the Orange compiler that the variable isn't defined now, but will be at linktime.
```
? malloc::(size:Int64)->&()
someFunction::()->() = {
    allocatedBytes: &() = malloc(16)
}
```
External declarations can have an optional external name. This is the name that will be generated by Orange, and can be different from the variable name used by Orange. This is useful when the external name would be awkward to work with.
```
sdl::Module = (
    // These two reference the same external function SDL_Init
    ?[SDL_Init] + init::(flags:Int32)->Int
    ? + SDL_Init::(flags:Int32)->Int
)
//...
myModule::Module = (
    + myFunction::()->() = {
        // Compare...
        sdl.init(0)
        // With...
        sdl.SDL_Init(0)
    }
)
```
If no external name is given, Orange will use the variable's name.

External variables do not need an expression since they will not be generated by Orange. However, for external types it can be useful to provide a representation to Orange about the structure of the external type.
```
// External C Code
typedef struct {
    int a;
    char b;
    float c;
} MyStruct;

// Orange Code
?[MyStruct] MyStruct_version1::Type

?[MyStruct] MyStruct_version2::Type = (
    a: Int
    b: Char
    c: Real
)

main::()->() = {
    version1: MyStruct_version1
    version2: MyStruct_version2

    version1.a = 5 // Error! Orange cannot verify if this is correct
    version2.a = 5 // Ok! Orange is able to verify that this is correct
}
```
Struct fields cannot be marked as external

### Public modifier
Variables can be marked as public using the `+` token, similar to UML. Public variables can be accessed in cousin scopes using the `.` operator. Variables that aren't explicitly defined as public are private. All variables both public and private are visible in child scope.
```
someModule::Module = (
    + visible: Int = 5
    invisible: Int = 7
)
// ...
otherModule::Module = (
    myInvisible: Char = '2'
    + main::()->() = {
        someModule.visible = 5      // Ok
        myInvisible = 5             // Ok
        someModule.invisible = 5    // Error! someModule's invisible variable is not public
    }
)
```
Struct fields are always public, though it is still syntactically correct to mark them as public if you really want to.
## Primitive types
## Structs
## Arrays
## Enums
## Functions
## Operators
## if
## for
## switch
## new/free
## defer
## Constants and comptime evaluation
## Errors, errdefer, try, catch
## Optionals, orelse
## Generics
## Methods
## Iterators
## Quantifiers
## Package system
## Testing