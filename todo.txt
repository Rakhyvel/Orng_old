x Surjective to C
	x different widths of ints, floats, etc
		x Int8 ~ Char
		x Int16
		x Int32 ~ Int
		x Int64
		x Nat8 ~ Bool
		x Nat16
		x Nat32 ~ Nat
		x Nat64
		x Real32 ~ Real
		x Real64
	x main function
	x void type, make it so that generator collects anonymous structs from variable symbol types
	x floating point
	x extern symbol modifier
	x public symbol modifier
	x hexadecimal and binary representation
	x negation
	x increment/decrement
	x sizeof, addrof
	x dereference
	x bitwise or, xor, and, shift left/right, not
	x <op>=
	x ternary operator
	x casting
	x break, continue
	x switch case
	x for loop
	x do while loop
	x Array struct type with length
	x New main function type to take a char array array
	x null
	x struct membership, check to see if symbol is addr
	x struct literals
	x varadic paramlist, array struct type with length
	x enum
	x assert <condition>
- Only produce correct, human readable output, or give error
	x Validate ASTs
	x validate types
	x for loop defs are within the block scope
	x smallest common set for math operation getType
	x break/continue must be in loop
	x add checks to see if symbol is comptime for things like dots
	x pull all common functionality into their own functions
	x re-add return, change function return type to be the type of what's being returned (no more pascal stuff)
		x check that all paths in a function return the correct value
	x &= and |= should be polymorphic on bools and ints
	x pull symbols into program tuple, pass to generator to generate
		x collect symbols / types and such
	x Sanitize error messages to not conain any % or \
	x Tokens and AST nodes store the position in the line that they occured on
		x "position" struct that holds filename, line, start, end for Tokens, and ASTs
	x Expand line buffer if full
	x print types got in error msg
		x vsprintf or something
	x difference between stack and heap arrays
		x array size will be ignored in declaration
		x array literals
			x all elements types must match 
			Orange:	x : Int[] = [1, 2, 3]
			C:		struct struct_3 x = (struct struct_3){(int[]){1, 2, 3}, 3};
		x new keyword which
			x callocates size of a non-array type
			x callocates an array struct with size
		x free keyword which
			x frees a regular pointer
			x frees an array
	x type inference
	x do "." instead of "->" if "&" operator is a parent
- std library
	- package and build system:
		x check if orange directory is created, create it if not
		x take in single compile directory instead
		x read and parse MANIFEST file
		x for each package, read in MANIFEST file from directory, parse as usual
			x add Package data type, symbol type
			x package identifer must be the same as the package directory
		x for each package, read in dependent packages if they're not already included, check for cycles
			x give an error if the package name can't be found
			x give an error if cycles are detected
				x search through depen 'tree' shouldn't give same package
		x for each package, read in any includes, add to a set of includes
		x for each package, read in orange files from packages, parse, validate, generate
			x validate that modules don't interact with modules in packages that their own parent doesn't depend on
		x error messages should just print out package/module instead of full filename
		x for first package, read in "outname" field, set that as the filename for the output file
		- restrict symbols
			x a list of aliases
				x <alias_ident> = <symbol_expr>
				x OR <alias_ident> (which is <alias_ident> = <alias_ident>)
			x when searching:
				x if identifier matches to an alias, return the aliases symbol (pre-determined)
				x if symbol from parent is not in the allowed symbols, return some error (tell user its rejected)
				x give error2 showing rejecting bracket
			x restrict blocks
	x function pointers (non-compiletime known symbols with function types)
	x std library -[]
	x util library -[std]
		x Arraylist
		x Linkedlist
		x Vector
	x SDL hooks -[]
	- also write a ECS and GUI for apps
	- put these all on github (should be really easy!)
	x package/module convention is all lowercase, to disambiguiate types and modules
		x enforce that file symbol and filename are the same for modules
		x enforce package name and package symbol are the same for packages
		x enforce against symbol shadowing
		x types must start with an uppercase letter
	x ability to alias modules, REMOVE ALIASES! 
	x only idents and dots allowed in restrictions
	x type inference for module, packages, and types
	x move restriction to before the symbol
	x change MANIFEST files to <pkg name>.orng files
	- doc generation
		- packages:
			- package docstring
			- what includes does this package have?
			- what other packages does this package depend on
			- public build symbols?
			- position?
		- modules:
			- docstring
			- what are the public functions, variables, types, and maybe even other modules in this module
			- what other modules does this module see
			- position?
		- types:
			- docstring
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- variables:
			- docstring
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- functions:
			- docstring
				- what are the parameters
				- what does it return
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- call graph visualization?
- fix varargs once and for all!
x ; to add multiple statements on one line
x for loop uses ; instead of , 
x 'else' for when a loop wasn't broken out of
x inner functions
x only generate reachable symbols
x defer & errdefer
	orng			c
	# start	block   bool defer_0 = 0;
	defer <code>	defer_0 = 1;
	# end	block	if (defer_0) <code>
x arrays
	x arrays are nothing more than a struct with a length field and data
	x pointers to structs can achieve length polymorphism
	ex:
	x arr:Int[5]				# an array of 5 integers
	x arr = [1, 2, 3, 4, 5]	# simple struct copy
	x arr2:Int[4]&			# a pointer to an array of fixed size
	x arr2 = &arr				# error! type mismatch because size mismatch
	x arr3:Int[]				# a pointer to an array of any size
	x arr3 = &arr				# works! length information is stored in arr, this is fine
	x String::Type = Char[]		# strings are POINTERS to an array of characters
x General cleanup
	x flip type syntax to better reflect array indexing
		x arr:Char[5][4]; arr[4][3] # fails arr[3][4] # works
		x arr:[5][4]Char; arr[4][3] # works
	x remove assert, should be something in stdlib.debug, along with panic, log, warn etc
	x Give me the paramlist def of the function for parameter/argument error2s
	x Calculate reachability for structs!!
	x Inner functions should not be able to see symbols in their parent function scope, should be scoped just inside nearest module
	x fix bug where `new [3][]Int` generates garbage new function call
	x Positions have start line & span, end line & span
	x error messages can print this out
	x AST nodes combine positions of their tokens
	x C array type for array struct data field type
		x when the type is gotten through dot it should be just the base type, so that C conversion works
	x remove ++ and --
	x remove while
	x generate extra braces around functions that aren't blocks
	x remove block comments, change comment syntax
x default params
	x definitions NOT in parameters have a default zero-value
	x same syntax as struct literals
	x IF positional AND too few arguments, BUT the rest are defaults
		x THEN extra AST nodes are inserted into the call to match the rest of the parameters
	x IF named
		x THEN the arguments are re-ordered based on the parameters
		x IF there are some that aren't given and are default parameters, they take their default parameter ASTs like with positional
	x positional call and named call syntax is disjoint, cannot mix the two
		x same with struct literals (make these the same in the parser!!)
	x otherFn(3, 'a', 4, 0.0) // A positional call
	x otherFn(3, 'd', 5) // Can leave out the LAST default parameters
	x otherFn(.x=4, .y='v', .z=3, .a=0.3) // A named call, notice the .<ident> so I don't have to deal with scoping
	x otherFn(.a=0.3, .z=3, .y='v', .x=4) // Same named call with parameters in different order
	x otherFn(.z=4, .x=args.length) // Can leave out any default, not just at the end
	x debug.assert takes in an optional message
x can't declare struct fields as extern
x change const type syntax and semantics
	pi::Real = 3.14159			// Cannot change value
	constPtr::&Int = null		// Cannot change value. Can modify memory
	freePtr:&:Int = null		// Cannot modify memory, can change value
	constConstptr::&:Int = null	// Cannot change value nor modify memory
x distinction between procedures which can have normal side-effects and functions which cannot
	x can't call procedures
	x can't dereference pointers
	x can't take addresses of
	x can't take in pointers
	x can't call new or free
	x can't reference external symbols
	x can't assign to variables outside of function's scope
x procedures inside structs
	x calls to a procedure defined in a struct are replaced with a call to a regular procedure (ok to do since they're comptime)
	x if reference to a struct is dotted, and a fuction that accepts the struct reference as its first argument is the right side of the dot, replace with procedure call and with struct reference as first argument
		ex:
		MyStruct::Type = (
			state:Int
			fn::(self:&MyStruct, incr:Int)->Int = {
				self.state += incr
			}
		)
		...
		x := new MyStruct
		MyStruct.fn(x, 4) // x's state increments by 4
		x.fn(4) // equivalent function call
	x enums have length field and toString procedure
x imitation LLVM
	x custom if, while, for loops using gotos(!)
	x basic blocks that either call another block or return from the function
	x all ASTs store their temporary values in temporary variables marked _x where x is a number
		x lvalues
		x short circuit && and ||
	x statements are expressions, return is implied = almost functional programming
		x blocks evaluate to the last expression in the block
		x if-else as a ternary operator (remove old ternary operator)
		x for loops evaluate to their block value
		x switches evaluate to their case's block's value
		x restricts evaluate to their block's value
		x returns set the return value of the function, jump to return path like normal
	x remove new struct functions, since it can now be done inline
	x defer, return, break, continue paths are correct?
	x breaks should bust out of switches
	x slices now that I can initialize arrays as expressions
		x slices are a pointer to an array and a length
		x syntax to create slices
			arr: [4]Int
			subArr := arr[2:4] -- Includes arr[2], does not include arr[4] obviously
			internally: 
			struct struct_3 _172_arr = {4, (int64_t[]){0, 0, 0, 0}}
			int64_t _0 = 4;
			int64_t _1 = 2;
			_172_subArr = {_0 - _1, arr.data + _1};
		x can omit either side
			arr: [4]Int
			sli := arr[0:4]
			sli := arr[:4] -- here 0 is infered
			sli := arr[0:] -- here the length of the base array is used
			sli := arr[:]  -- here both 0 and length of base array is used
		x syntax to initialize arrays on new, and structs as well
		<new> <type> (<array-literal> | <arglist>)?
	x no syntactical difference between procedures and functions, just confuses things. Just check if FUNCTION is stateless (remove procedure)
	x shorten stdlib to std
	x rework restrictions to only restrict sibling symbols. Error if a symbol is not a sibling?
	x find a way to make multi line strings, the way I have it now isnt tokenizable line-by-line
x Rework the compiler to be better [ast-union-type]
	x case/mapping rather than switch/case
	x use a union for AST Nodes, like you would if you were to rewrite this in Orng
		x create function to create an AST for every possible AST type
		x no more guessing the child element in a list! Can now just use it
- unions like in julia and haskell
	x Tagged union and enums
		x generate union type structs
		x coerce to union
		x union dot constructor
		x union case
		x void type is implied if no type is given
		x validate that members in union must have either a unique type, or the void type
		- in field cases, make it so that you need to union name
	- Maybe type union
		x ?<Type> which is just shorthand for (|nothing,  just:<Type>)
		x can use the name of the maybe variable as-is if the compiler can reason about whether or not the variable is nothing
			x weak SAT model:
			sat::(expr:&AST, assumption:Bool)->(trueASTs:?&List(&AST), falseASTs:?&List(&AST)) =
				case expr {
					.not -> sat(expr.expr, !assumption)								-- flip assumption
					.and -> if assumption {
							union(sat(expr.left, true), sat(expr.right, true))		-- if assuming expr is true, both left and right must be true
						} else
							(nothing, nothing)										-- if assuming expr is false, cannot say anything about left and right
						}
					.or  -> if !assumption {
							union(sat(expr.left, false), sat(expr.right, false))	-- if assuming expr is false, both left and right must be false
						} else
							(nothing, nothing)										-- if assuming expr is true, cannot say anything about left and right
						}
					else ->  if assumption {
							(List(&AST).create([expr]), nothing)					-- if assuming expr is true, expr is true
						} else
							(nothing, List(&AST).create([expr]))					-- if assuming expr is false, expr is false
						}
				}
		x replace uses of symbol when a known field is active with that field
		x generate nothing comparisons
		x assumptions for for loops too
		x orelse operator
x Generate IR from AST
	x basic block, call graph, etc
x Generate C code from IR
- IR optimizations
	x constant propagation
	x copy propagation
		x requires symbol versioning
	x dead code trimming
		x requires symbol versioning, phi nodes etc
	x default values
	x arrays
		x array literals, 
		x default array literals
		x indexing
	x structs
		x arglist literals
		x default arglists
		x dots
		x slices (which are special arglists! no array literals!)
		x deref inference for dots is a front-end thing, insert deref AST nodes
	x index-copy
	x dot-copy
	x unops
		x deref-copy
	x and/or
	x binops
		x bit or
		x bit xor
		x bit and
		x left shift
		x right shift
		x equals
		x not equals
		x greater
		x lesser
		x greater than or equal to
		x less that or equal to
		x add
		x sub
		x mult
		x div
		x mod
	x make validateAST not do optimizations
	x make validateAST require coerceType (why didn't I do this before? hmm)
	x coalesce validateAST cases
	x op-assign
		x add &&= and ||=
	x fun little optimizations for binops and unops
		x bit or-ing 0
		x left/right shifting 0
		x adding/subbing 0
		x multing/diving/modding 1
		x multing 0
		x known value computations for all binops
	x 0 <= index < array size
	x slice lower bound < slice upper bound
	x cannot divide by zero
	- x:[-3]Int causes infinite loop
	- new
	- free
	- strings
	- casts and type conversions
	- calls
		- function arguments
	- cases
		- some sort of set of mappings and their integer conditions so that duplicates can be detected
		- what time are field case expressions?
		- change syntax so that only one field mapping can have one codomain thingy
	- union literals & default union literals
	- orelse, field cases, SAT (possibly for optimizations, too!)
- Orange should compile the program for you, too
	- No verbatims, instead write the C file and header, include it, and add it to be included when compiling
- Go back to adding errors and union type unions
	- runtime errors
		- || type operator that operates on any union sets
			- combines left and right union sets
			- ok for names to collide, so long as their types are EQUAL (not just subtype)
			- how do tags work? How can I coerce a union literal?
				- conversion instruction that maps sub union tags to super union tags
			Color::Type = (|
				red			-- tag = 0
				orange		-- tag = 1
				blue		-- tag = 2
			)
			Fruit::Type = (|
				orange		-- tag = 0
				apple		-- tag = 1
				banana		-- tag = 2
			)
			Color || Fruit ::Type = (|
				red			-- tag = 0
				orange		-- tag = 1
				blue		-- tag = 2
				apple		-- tag = 3
				banana		-- tag = 4
			)
			x : Color || Fruit = Color.orange -- needs to be coerced up to superset
		- <UnionSetType>!<Type> type operator
			- shorthand for (|success:<Type>) || <UnionSetType>
			- binds looser than ||
			- errors are regular unions, become errors with the ! operator
			- no global error set, but there is the AnyError type which is the union of all error unions
		- can case on an error union just like any other union set
			-- uses if-def idiom, very useful! implement it now!!!
			file = case fileErr := openFile("filename.txt"); fileErr {
				.Success -> fileErr
				.FileNotFound -> {
					std.system.println("could not find the file")
					return fileErr
				}
				.FileInUse -> {
					std.system.println("file is in use by another program")
					return fileErr
				}
			}
		- try unwraps value if no error, or returns the error
		- catch unwraps value if no error, or evaluates to default expression
		- errdefer is another return exit path if return is an error, a subset of defers (ie it defers all defers, and also errdefers if return is error)
- &&= and ||= operator for &&= and ||=, do not make &= and |= polymorphic
- cleanup!
	- replace for loops over lists with forall loops
	- comments on everything
	- fix enum and switch order to be consistent
	- change references to "double" to "real"
	- fix and consistify spelling of ASTs and IRs and Tokens and everything else
	- write a markup to html program (in orange, add to github) and write tutorial/documentaiton
	- reorder functions to be in prefix order, fix header order
	- variable name semantics
		- 'type' for AST nodes that are types
		- 'node' for other AST nodes
		- 'ir' for IRs
		- 'bb' for Basic Blocks
		- 'token' for Tokens
		- 'cfg' for a CFG
		- 'pos' for a Position
		- 'symbol' for a SymbolNode (not 'scope')
- 'default' keyword which takes in a type and gives its default value
	if x == default Int64 {
		std.system.println("x is 0")
	}
	- useful for variants and allocators
	new::(T::Type, init::T=default T)->AllocationError!&T = {
		malloc?::(size:Int64)->&Any
		retval := malloc(sizeof T):&T
		*retval = init
		return retval
	}
	-- usage:
	create::(alloc:&Allocator)->!&Whatever = {
		retval := try alloc.new(Whatever, ("This is the default\n", 34, 535.5))
		
	}
- parametric types
	- you would need a function that 'returns' a type
		- this would require a unification of type and value syntax
		- can I find any instances where this leads to ambiguity that cannot be solved?
			- addr-of type and addr-of value must be treated differently
		- 'parameterized types', instead of a full blown function that returns a type
	- if a function takes in all compile-time constant arguments and returns something compile-time constant, replace call with function definition
		- can do this because:
		- referential transparency- most function calls can simply be replaced with their definition
		- all parameters are compile-time known, can simply replace references to the parameters with the arguments in the definition
			- doesn't this imply we'd need to clone the def AST?
	- rewrite util data structures to be variant
	- typeof operator which gets the compiletime type of an expression
	- subtype operator which does compile time type checking
- interfaces (traits in rust https://theburningmonk.com/2015/05/rust-memory-safety-without-gc/)
	- are just structs with Any pointers to the base data structure, and function pointers
	- add method calling for stack structs, just take the address in the call
	- https://www.nmichaels.org/zig/interfaces.html interfaces in Zig
		- compose an interface within each struct
		- requires a backwards pointer, and knowdledge of memory alignment
	- https://zig.news/kilianvounckx/zig-interfaces-for-the-uninitiated-an-update-4gf1
	- other implementations have vtables which are passed along with the interface and a pointer to the base data, better
	- possibly like typeclasses in Haskell? WANT!
		Iter::Class = (
			next:(self:&Iter)->&Iter
		)
	- should be able to define NEW data types that OLD functions work with
	- should be able to define NEW functions that apply to OLD data types
- refinement types, contracts, pre/post conditions
	- why?
		- comments are useless
		- often times code will change and the comments will become wrong
		- comments are not checked by compiler
		- comments are rarely checked by programmer
		- refinement types WILL be checked by compiler, and pre/post conditions WILL be checked by compiler
		- comments should be kept, but only used to provide a convenient way to enumerate what to document
	Evens::Type = {x : Int | x % 2 == 0} -- Would be checked for debug build, not checked for release build
	- are an expression, need another expression after them
	- can chain them and other expressions together
	arcsin::(x:Real)->Real = 
	|>	-1 <= x <= 1		-- this expression is evaluated, if its false program hard crashes
	|<	y; sin(y) == x		-- post conditions capture the return value, then have the expression
	{
		-- do math here
	}
	- |> for pre condition (like input)
	- |< for post condition (like output!)
	- maybe a post condition built in expression for like "|< no IO output happened during this function"
	- conceptually, |> evaluates itself, then evaluates child
	- |< evaluates its child at the end of the chain, captures it and performs condition
- allocators and IO 'monads'
	new::(T::Type)->?&T = 
		if retval := calloc(sizeof T, 1):&T; (retval:Int) == 0 {
			nothing
		} else {
			*retval = default T -- since there's no new, there's no way to force allocators to set a default, but there should be a way to get a default value of a struct
			retval
		}
- immutability
	- variables are always "readers" of data
	- mutable variables can be writers of data
	- immutable variables cannot be writers of data
	- f ::(x:Real)->Real = {y::Real = x; y} -- not possible, x isn't comptime known
	  f`::(x:Real)->Real = {y:-Real = x; y} -- possible! y is runtime constant, ie always a reader and never a writer
	- can enforce read-only through types!
	  y:-Real = 0.4
	  z:&-Real = &y
	  g:-Real = *z -- maybe change deref token so its not confused with multiplication across newlines
	  *z = 5.6 -- Cannot do! z is of type &-Real, *z is of type -Real, cannot reassign! Easy!
- @attributes, then test suite
	- define a type, can then congregate those symbols at compiletime in an array
	- global namespace? or maybe a separate namespace from other identifiers
	- @[stdlib.main] for main function
		@main::Attribute = :(args:[]String)->!()
		@[stdlib.main]
		whateverName::(args:[]String)->!() = { ... }
	- test suite with @[...] for attributes
		test::Attribute = ()->()! # What type do symbols with this attribute have?
		@[test]
		test_something::()->!() = {
			stdlib.debug.assert(4 == 5)
		}

		main::(args:String[])->Int = {
			tests ::= thisModule@test # an array of the test functions, maybe with some wrapper stuff like name, filename, line etc (what symbols have (give the user complete access to symbol tree/ASTs?))
			for t : tests {
				failed := false
				try t() catch {
					stdlib.system.println("Error")
					failed = true
				}
				if !failed {
					stdlib.system.println("Success")
				}
			}
		}
- `if let` from zig or odin or whatever
	// Wrap if in a separate scope
	if node := isASTStateful(symbol->def); node != NULL && symbol.symbolType == SYMBOL_FUNCTION {
		
	} else if node % 2 != 0 {
		
	}
	INCREDIBLY USEFUL FOR DEFINING AN IDENT AS A DOT AND CHECKING FOR NOTHING!
	since you we can't reason about dots, can only reason about ident symbols
	can assign an ident to a dot, which then 
- language server for visual studio code
- quantifiers from Alloy- or maybe these would be better as interfaces?
	- basically just iterators, use interface above
	- should be expressions, generate as a function call
	- for x : X  {}		# for each loop
	- all x : X, P		# all x in X satisfy P
	- some x : X, P		# one or more x in X satisfy P









Maybe?
- Cool math syntax (i really like these and it should be done!)
	- arglist-assign
		Vec::Type = (x:Int, y:Int)
		(x, y) = Vec_Create() -- Creates a Vec
		x = 4
		y = x + ys
	- exponentiation (useful) instead of bitwise xor (not as useful)
		- circleArea::(r:Real)->Real = 3.1415 * r ^ 2
		- generates as pow() or powf() function
	- adjacent multiplication
		- circleArea::(r:Real)->Real = 3.1415 r^2
	- relational operator chaining
		- exclusive with implicit eq above
		- have to be transitive operators (== < <= > >=)
			_0 = 0 -- init chain result as false
			_1 = 0 -- init first child

			_2 = x	-- basic pattern is init next child, comp with prev child
			if !(_1 < _2) goto over_1 -- if any comparison is false, jump to false

			_3 = 100 -- init next child
			if !(_2 < 100) goto over_1

			_0 = 1	-- If we get here, result is true
		over_1:; -- end of chain
		- Syntax is weird to parse, need to loop over possible chains, but how to keep track of the symbols for each operator?

- implicit dereferencing, like how C++ uses references
	- there is a sharp distinction between C++ references and pointers
	- references cannot be reassigned
	- perhaps references can be thought of as constant addresses
	- addrOf returns a constant address
	- these will not be memoized during comptime eval, because addresses aren't comptime constant, but they could be runtime constant in the scope of the function
	- maybe even a different syntax, with ^ for pointers and & for references, with references having implicit dereference and pointers not having that
	- & operator would give "reference", where as ^ would give pointer type, dereferencing a pointer would use * as normal
	- Was is the valid use case for this?? Seems kind of useless when pointers work fine, and there is no pointer arithmetic
		- A pointer now can be marked as &:T, so that T is constant and cannot be changed by the callee
		- however, this would require coercing T to :T, which is not possible
		- maybe T <: :T, and &T = &:T ?? strange

- structural type inference
	- requires than '=', ')' and ',' are not in type alphabet, reasonable
	- x:&               = giveMeAnAddress()    -- x is an address to ... something! Type is infered
	- x::               = 5					   -- already supported! x is a compile time constant, type is infered
	- x:-               = 4.3				   -- x is a runtime constant, type is infered (would be nice to have!!!!)
	- x:[]              = [3, 4, 5]			   -- x is an array of any size, type is infered. Not as useful
	- x:(a:Int, b:, c:) = (3, 4, 5)			   -- x is a struct with an int a field, and a b and c field that are type infered

- Orange should be able to parse C header files
	- would be cool if Orange was compatible with C both ways, especially if you were to switch to Orange in a C codebase
	- finds types and functions, adds them as external with the name of the header file being the name of the module automatically and everything with externs happening automatically
	- would be tricky with macros