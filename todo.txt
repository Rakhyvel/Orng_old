x Surjective to C
	x different widths of ints, floats, etc
		x Int8 ~ Char
		x Int16
		x Int32 ~ Int
		x Int64
		x Nat8 ~ Bool
		x Nat16
		x Nat32 ~ Nat
		x Nat64
		x Real32 ~ Real
		x Real64
	x main function
	x void type, make it so that generator collects anonymous structs from variable symbol types
	x floating point
	x extern symbol modifier
	x public symbol modifier
	x hexadecimal and binary representation
	x negation
	x increment/decrement
	x sizeof, addrof
	x dereference
	x bitwise or, xor, and, shift left/right, not
	x <op>=
	x ternary operator
	x casting
	x break, continue
	x switch case
	x for loop
	x do while loop
	x Array struct type with length
	x New main function type to take a char array array
	x null
	x struct membership, check to see if symbol is addr
	x struct literals
	x varadic paramlist, array struct type with length
	x enum
	x assert <condition>
- Only produce correct, human readable output, or give error
	x Validate ASTs
	x validate types
	x for loop defs are within the block scope
	x smallest common set for math operation getType
	x break/continue must be in loop
	x add checks to see if symbol is comptime for things like dots
	x pull all common functionality into their own functions
	x re-add return, change function return type to be the type of what's being returned (no more pascal stuff)
		x check that all paths in a function return the correct value
	x &= and |= should be polymorphic on bools and ints
	x pull symbols into program tuple, pass to generator to generate
		x collect symbols / types and such
	x Sanitize error messages to not conain any % or \
	x Tokens and AST nodes store the position in the line that they occured on
		x "position" struct that holds filename, line, start, end for Tokens, and ASTs
	x Expand line buffer if full
	x print types got in error msg
		x vsprintf or something
	x difference between stack and heap arrays
		x array size will be ignored in declaration
		x array literals
			x all elements types must match 
			Orange:	x : Int[] = [1, 2, 3]
			C:		struct struct_3 x = (struct struct_3){(int[]){1, 2, 3}, 3};
		x new keyword which
			x callocates size of a non-array type
			x callocates an array struct with size
		x free keyword which
			x frees a regular pointer
			x frees an array
	x type inference
	x do "." instead of "->" if "&" operator is a parent
- std library
	- package and build system:
		x check if orange directory is created, create it if not
		x take in single compile directory instead
		x read and parse MANIFEST file
		x for each package, read in MANIFEST file from directory, parse as usual
			x add Package data type, symbol type
			x package identifer must be the same as the package directory
		x for each package, read in dependent packages if they're not already included, check for cycles
			x give an error if the package name can't be found
			x give an error if cycles are detected
				x search through depen 'tree' shouldn't give same package
		x for each package, read in any includes, add to a set of includes
		x for each package, read in orange files from packages, parse, validate, generate
			x validate that modules don't interact with modules in packages that their own parent doesn't depend on
		x error messages should just print out package/module instead of full filename
		x for first package, read in "outname" field, set that as the filename for the output file
		- restrict symbols
			x a list of aliases
				x <alias_ident> = <symbol_expr>
				x OR <alias_ident> (which is <alias_ident> = <alias_ident>)
			x when searching:
				x if identifier matches to an alias, return the aliases symbol (pre-determined)
				x if symbol from parent is not in the allowed symbols, return some error (tell user its rejected)
				x give error2 showing rejecting bracket
			x restrict blocks
	x function pointers (non-compiletime known symbols with function types)
	x std library -[]
	x util library -[std]
		x Arraylist
		x Linkedlist
		x Vector
	x SDL hooks -[]
	- also write a ECS and GUI for apps
	- put these all on github (should be really easy!)
	x package/module convention is all lowercase, to disambiguiate types and modules
		x enforce that file symbol and filename are the same for modules
		x enforce package name and package symbol are the same for packages
		x enforce against symbol shadowing
		x types must start with an uppercase letter
	x ability to alias modules, REMOVE ALIASES! 
	x only idents and dots allowed in restrictions
	x type inference for module, packages, and types
	x move restriction to before the symbol
	x change MANIFEST files to <pkg name>.orng files
	- doc generation
		- packages:
			- package docstring
			- what includes does this package have?
			- what other packages does this package depend on
			- public build symbols?
			- position?
		- modules:
			- docstring
			- what are the public functions, variables, types, and maybe even other modules in this module
			- what other modules does this module see
			- position?
		- types:
			- docstring
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- variables:
			- docstring
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- functions:
			- docstring
				- what are the parameters
				- what does it return
			- what is its type?
			- is it external? What is it's extern name?
			- position?
			- orange definition (with CFG highlighting!)
		- call graph visualization?
- fix varargs once and for all!
x ; to add multiple statements on one line
x for loop uses ; instead of , 
x 'else' for when a loop wasn't broken out of
x inner functions
x only generate reachable symbols
x defer & errdefer
	orng			c
	# start	block   bool defer_0 = 0;
	defer <code>	defer_0 = 1;
	# end	block	if (defer_0) <code>
x arrays
	x arrays are nothing more than a struct with a length field and data
	x pointers to structs can achieve length polymorphism
	ex:
	x arr:Int[5]				# an array of 5 integers
	x arr = [1, 2, 3, 4, 5]	# simple struct copy
	x arr2:Int[4]&			# a pointer to an array of fixed size
	x arr2 = &arr				# error! type mismatch because size mismatch
	x arr3:Int[]				# a pointer to an array of any size
	x arr3 = &arr				# works! length information is stored in arr, this is fine
	x String::Type = Char[]		# strings are POINTERS to an array of characters
x General cleanup
	x flip type syntax to better reflect array indexing
		x arr:Char[5][4]; arr[4][3] # fails arr[3][4] # works
		x arr:[5][4]Char; arr[4][3] # works
	x remove assert, should be something in stdlib.debug, along with panic, log, warn etc
	x Give me the paramlist def of the function for parameter/argument error2s
	x Calculate reachability for structs!!
	x Inner functions should not be able to see symbols in their parent function scope, should be scoped just inside nearest module
	x fix bug where `new [3][]Int` generates garbage new function call
	x Positions have start line & span, end line & span
	x error messages can print this out
	x AST nodes combine positions of their tokens
	x C array type for array struct data field type
		x when the type is gotten through dot it should be just the base type, so that C conversion works
	x remove ++ and --
	x remove while
	x generate extra braces around functions that aren't blocks
	x remove block comments, change comment syntax
x default params
	x definitions NOT in parameters have a default zero-value
	x same syntax as struct literals
	x IF positional AND too few arguments, BUT the rest are defaults
		x THEN extra AST nodes are inserted into the call to match the rest of the parameters
	x IF named
		x THEN the arguments are re-ordered based on the parameters
		x IF there are some that aren't given and are default parameters, they take their default parameter ASTs like with positional
	x positional call and named call syntax is disjoint, cannot mix the two
		x same with struct literals (make these the same in the parser!!)
	x otherFn(3, 'a', 4, 0.0) // A positional call
	x otherFn(3, 'd', 5) // Can leave out the LAST default parameters
	x otherFn(.x=4, .y='v', .z=3, .a=0.3) // A named call, notice the .<ident> so I don't have to deal with scoping
	x otherFn(.a=0.3, .z=3, .y='v', .x=4) // Same named call with parameters in different order
	x otherFn(.z=4, .x=args.length) // Can leave out any default, not just at the end
	x debug.assert takes in an optional message
x can't declare struct fields as extern
x change const type syntax and semantics
	pi::Real = 3.14159			// Cannot change value
	constPtr::&Int = null		// Cannot change value. Can modify memory
	freePtr:&:Int = null		// Cannot modify memory, can change value
	constConstptr::&:Int = null	// Cannot change value nor modify memory
x distinction between procedures which can have normal side-effects and functions which cannot
	x can't call procedures
	x can't dereference pointers
	x can't take addresses of
	x can't take in pointers
	x can't call new or free
	x can't reference external symbols
	x can't assign to variables outside of function's scope
x procedures inside structs
	x calls to a procedure defined in a struct are replaced with a call to a regular procedure (ok to do since they're comptime)
	x if reference to a struct is dotted, and a fuction that accepts the struct reference as its first argument is the right side of the dot, replace with procedure call and with struct reference as first argument
		ex:
		MyStruct::Type = (
			state:Int
			fn::(self:&MyStruct, incr:Int)->Int = {
				self.state += incr
			}
		)
		...
		x := new MyStruct
		MyStruct.fn(x, 4) // x's state increments by 4
		x.fn(4) // equivalent function call
	x enums have length field and toString procedure
- imitation LLVM
	x custom if, while, for loops using gotos(!)
	x basic blocks that either call another block or return from the function
	x all ASTs store their temporary values in temporary variables marked _x where x is a number
		x lvalues
		x short circuit && and ||
	x statements are expressions, return is implied = almost functional programming
		x blocks evaluate to the last expression in the block
		x if-else as a ternary operator (remove old ternary operator)
		x for loops evaluate to their block value
		x switches evaluate to their case's block's value
		x restricts evaluate to their block's value
		x returns set the return value of the function, jump to return path like normal
	x remove new struct functions, since it can now be done inline
	x defer, return, break, continue paths are correct?
	x breaks should bust out of switches
	- slices now that I can initialize arrays as expressions
		x slices are a pointer to an array and a length
		x syntax to create slices
			arr: [4]Int
			subArr := arr[2:4] -- Includes arr[2], does not include arr[4] obviously
			internally: 
			struct struct_3 _172_arr = {4, (int64_t[]){0, 0, 0, 0}}
			int64_t _0 = 4;
			int64_t _1 = 2;
			_172_subArr = {_0 - _1, arr.data + _1};
		x can omit either side
			arr: [4]Int
			sli := arr[0:4]
			sli := arr[:4] -- here 0 is infered
			sli := arr[0:] -- here the length of the base array is used
			sli := arr[:]  -- here both 0 and length of base array is used
		x syntax to initialize arrays on new, and structs as well
		<new> <type> (<array-literal> | <arglist>)?
	x no syntactical difference between procedures and functions, just confuses things. Just check if FUNCTION is stateless (remove procedure)
	x shorten stdlib to std
	x rework restrictions to only restrict sibling symbols. Error if a symbol is not a sibling?
	- find a way to make multi line strings, the way I have it now isnt tokenizable line-by-line
- unions like in julia and haskell
	- Only practical uses are Either, and Maybe. Either is only ever used to pass error messages
	- Tagged union and enums
		Syntax: (|| <ident> (:<type>)? (=<constexpr int>)?)+
		- void type is implied if no type is given
		- void fields in unions aren't generated, but their type is still used
		- number is assigned if none is given. Clashes are not permitted
		- accessing the identifier through a union namespace evaluates to the type_id for that identifier
		- enums are tagged unions with the identifiers having a default void value
		MyUnion::Type = || int:Int || char:Char || nothing
		MyEnum::Type = || RED || BLUE || GREEN
	- runtime errors
		- !<Type> which is just shorthand for || Error || <Type>
		- return an error code, maybe with a message? (how do stack traces error messages work?)
		- try unwraps value if no error, or returns the error
		- catch unwraps value if no error, or evaluates to default expression
		- errdefer is another return exit path if return is an error, a subset of defers (ie it defers all defers, and also errdefers if return is error)
		- array indexing checks array size, returns error if out of bounds (panic instead of giving an option to catch)
		- panic if new fails
	- Void type union
		- ?<Type> which is just shorthand for || Nothing || <Type>
		- only void typed symbols can be null, null is of type void
		- else-less if statements give optional types
			x: ?Int = if true; 5
- compile time evaluation
	- GOOD RULE OF THUMB:
		if it'd be a pain to implement for compile-time evaluation, don't add it as a feature
		LESS features is better!
	- convert AST to IR before, evaluate this, then 1:1 generate it out
		- simpler to generate
		- this could also be part of the validation step
		  0. memoize IR if it's already converted
		  1. validate AST
		  2. convert to IR
		  2.5. do optimizations?
		  3. evaluate IR
		  4. store IR back into function
		     if function has comptime parameters, memoize arguments to result
			 if variable, create new IR with constant evaluate value
		- this way the evalator CAN use pointers and allocate memory intermediately, just cannot be lasting value
	- for every compile-time constant variable, validate it's AST and evaluate it, replacing it's AST with the result
	- setup a runtime environment with stackframes and a map of variable names to a "value" union
		- values can be integer, string, array literal, whatever
		- probably can't be pointers since that would be hard (but Jai does it somehow...)
	- validate that all switch cases are unique numbers
	- validate that all switch case exprs are comptime
	- validate that default function parameters and struct fields are constant expressions
	- if index is comptime, must be postive
	- if denominator is comptime, must not be 0
	- dead code trimming
	- calls to functions with all comptime parameters are memoized
		- map input parameter values -> output value or AST (choose)
- generics
	- you would need a function that 'returns' a type
		- make types expressions so that `return <type>` works
		- may need to write out grammar for this to work, but after this is should be pretty much solidified
	- if comptime, acts as generics
	- if runtime, a separate function is "stamped" and memoized, this function is called
	- allocators with free and new methods that take in addrs and types, replace free and new
- interfaces (traits in rust https://theburningmonk.com/2015/05/rust-memory-safety-without-gc/)
	- https://www.nmichaels.org/zig/interfaces.html interfaces in Zig
		- compose an interface within each struct
		- requires in-struct function definitions, which shouldn't be too much of a problem
	- interfaces define a list of functions for a struct type
	- if there exists function definitions for the struct type ANYWHERE in the program, the struct type implements the interface
- quantifiers from Alloy- or maybe these would be better as interfaces?
	- basically just iterators, use interface above
	- should be expressions, generate as a function call
	- for x : X  {}		# for each loop
	- all x : X, P		# all x in X satisfy P
	- some x : X, P		# one or more x in X satisfy P
- LLVM (?)
- @attributes
	- define a type, can then congregate those symbols at compiletime in an array
	- global namespace? or maybe a separate namespace from other identifiers
	- @[stdlib.main] for main function
		@main::Attribute = :(args:[]String)->!()
		@[stdlib.main]
		whateverName::(args:[]String)->!() = { ... }
	- test suite with @[...] for attributes
		test::Attribute = ()->()! # What type do symbols with this attribute have?
		@[test]
		test_something::()->!() = {
			stdlib.debug.assert(4 == 5)
		}

		main::(args:String[])->Int = {
			tests ::= thisModule@test # an array of the test functions, maybe with some wrapper stuff like name, filename, line etc (what symbols have (give the user complete access to symbol tree/ASTs?))
			for t : tests {
				failed := false
				try t() catch {
					stdlib.system.println("Error")
					failed = true
				}
				if !failed {
					stdlib.system.println("Success")
				}
			}
		}
- rewrite in Orng
- `if let` from zig or odin or whatever
	// Wrap if in a separate scope
	if node := isASTStateful(symbol->def); node != NULL && symbol.symbolType == SYMBOL_FUNCTION {
		
	} else if node % 2 != 0 {
		
	}
- pre and post condition contracts
	- are an expression, need another expression after them
	- can chain them and other expressions together
	arcsin::(x:Real)->Real = 
	|>	-1 <= x <= 1		-- this expression is evaluated, if its false program hard crashes
	|<	y; sin(y) == x		-- post conditions capture the return value, then have the expression
	{
		-- do math here
	}
	- |> for pre condition (like input)
	- |< for post condition (like output!)
	- maybe a post condition built in expression for like "|< no IO output happened during this function"
	- conceptually, |> evaluates itself, then evaluates child
	- |< evaluates its child at the end of the chain, captures it and performs condition

	
- relational operator chainings ????
	- wasn't possible before because of duplication of code. Now that can be inlined
	- have to be transitive operators (== < <= > >=)
		_0 = 0 -- init chain result as false
		_1 = 0 -- init first child

		_2 = x	-- basic pattern is init next child, comp with prev child
		if !(_1 < _2) goto over_1 -- if any comparison is false, jump to false

		_3 = 100 -- init next child
		if !(_2 < 100) goto over_1

		_0 = 1	-- If we get here, result is true
	over_1:; -- end of chain
	- Syntax is weird to parse, need to loop over possible chains, but how to keep track of the symbols for each operator?